## Тестовое задание

### Теоретическая часть

1. Вопрос: Какой командой в Linux-консоли можно вывести предпоследнюю строку текстового файла file.txt?

Самым простым вариантом решения я считаю следующее:
```bash
$ tail -2 file.txt | head -1 file.txt
```

Однако вопрос содержит несколько неоднозначную формулировку, поэтому приведу пример решения с помощью **одной** утилиты:
```bash
$ sed -n -e '$ d' < file.txt | sed -n -e '$p'
```

Написал по мере своего опыта использования данной утилиты. `-n` уберёт вывод строки паттерна, `-e` обозначит команду для выполнения, `'$ d'` удалит последнюю строку, затем выводится уже последняя строка.

*Refs:*
- https://grymoire.com/Unix/Sed.html

---

2. Вопрос: Какой командой в Linux-консоли можно посмотреть HTTP-код ответа вебсервера на GET-запрос ресурса http://example.com/getData

Т.к. ограничений на утилиты нет, я использую *curl*
```bash
$ curl -i -s -X GET http://example.com/getData | head -n1 | awk '{print $2}'
```
Здесь, согласно документации утилиты, будут включены заголовки ответа (`-i`), не будет выведена шкала прогресса (`-s`). В первой строке вывода будет код весрия протокола, код ответа и описание, откуда awk возьмёт только код. `-X GET` можно опустить, т.к. это поведение по-умолчанию.

Решение можно сократить (до использования одной утилиты) следующим образом:
```bash
$ curl -o /dev/null -s -w "%{http_code}" http://example.com/getData
```

Здесь тело запроса будет перенаправлено в `/dev/null`, а опция `-w` повзоляет использовать заранее определённые в curl переменные, чтобы получить значения, в данном случае код ответа.

Решение можно получить и с помощью утилиты `wget`, но оно не будет выглядеть короче.

*Refs:*
- https://www.opennet.ru/man.shtml?topic=curl&category=1&russian=3
- https://www.opennet.ru/man.shtml?topic=wget&russian=3&category=&submit=%F0%CF%CB%C1%DA%C1%D4%D8+man

---

3. Вопрос: Что такое VIRT и RES в выводе Linux-команды top? Чем они отличаются?

Команда `top` обеспечивает вывод системной информации, отображает состояние машины в реальном времени. В её возможности входит вывод потребляемой памяти каждым процессом, где мы и можем наблюдать поля `VIRT` и `RES`.

`VIRT` - виртуальный размер памяти процесса, т.е. суммарный размер всего, что может занять процесс в памяти, включая те участки, которые ещё не загружены в оперативную память. Суммарный размер выделенной памяти процессу.

`RES` – согласно документации, это подмножество виртуального адресного пространства (VIRT), представляющее физическую память, которую использует процесс за исключенем `swap-памяти`. Т.е. это та память, которая подгружена в физическую память. Она так же включает разделяемые библиотеки. Состоит из суммы следующих значений: `RSan`, `RSfd`, `RSsh`.

- RSan – страницы, не связаные напрямую с файлами на диске, например, вызов `malloc`.
- RSfd – страницы, которые связаны с файлами на диске, в т.ч. разделяемые библиотеки, исполняемые файлы, вызов `mmap` (например, позволяет работать с файлами как с областью памяти).  
- RSsh – это страницы физической памяти, которые используют несколько процессов одновременно, например, через разделяемые библиотеки.

*Refs:*
- https://man7.org/linux/man-pages/man1/top.1.html
- https://www.opennet.ru/man.shtml?topic=mmap&category=2&russian=0
- https://profhelp.com.ua/articles/%D0%BE%D1%82%D0%BB%D0%B8%D1%87%D0%B8%D0%B5-%D0%BC%D0%B5%D0%B6%D0%B4%D1%83-virt-res-%D0%B8-shr-%D0%B2-%D0%B2%D1%8B%D0%B2%D0%BE%D0%B4%D0%B5-%D0%BA%D0%BE%D0%BC%D0%BC%D0%B0%D0%BD%D0%B4%D1%8B-top

---

4. Вопрос: Что такое cgroups? Приведите пример, в котором это может быть использовано.

`cgroups` - (control groups) возможность, особенность ядра Linux, которая позволяет управлять ресурсами процессов и их групп. Т.е. можно ограничить объём потребляемой памяти, использование процессора, сетевой трафик и т.д. А вообще это один из основных механизмов на котором построен Docker, который ограничивает контейнеры в использовании ресурсов.

Так есть т.н. подсистемы, о которых можно почитать, например, тут: https://0xax.gitbooks.io/linux-insides/content/Cgroups/linux-cgroups-1.html.

*Refs:*
- https://wiki.archlinux.org/title/Cgroups
- https://habr.com/ru/companies/selectel/articles/279281/
- http://www.haifux.org/lectures/299/netLec7.pdf

---

5. Вопрос: Что общего между продуктами Logstash, Apache Flume, Filebeat?

У всех трёх компонент есть общая задача: сборка, обработка, и передача логов. Позволяют эффективно доставлять их в  хранилище. У всех трёх инструментов есть вомзможность расширять их за счёт плагинов, они поддерживают разные источники данных. Все три поддерживают потоковую передачу данных. Logstash: сбор, обработка, передача; Flume: сбор, агрегация, передача; Filebit: сбор, передача.

*Refs:*
- https://www.elastic.co/guide/en/beats/filebeat/current/filebeat-overview.html
- https://flume.apache.org/releases/content/1.11.0/FlumeUserGuide.html

---

6. Вопрос: Чем отличаются продукты InfluxDB и Prometheus? В каких случаях они взаимозаменяемы?

Это две системы для обработки временных рядов данных. У обех есть свой язык запросов, но по-умолчанию Promethues позволяет собирать данные, хранить данные, запрашивать их, проводить оповещения (Alertmanager хотя и будет сторнней частью, но может настраиваться прямо в интерфейсе Prometheus), тогда как InfluxDB определяет хранение данных. InlfuxDB может работать с большим набором типов данных, и обрабатывать данные на промежетку наносекунд. Обычно, ожидается, что Prometheus работать по pull-модели, а вот в InfluxDB данные должен кто-то положить.

В силу особенностей хранения данных (см. документацию) InfluxDB может быть использован для записи событий, а не простого добавления метрик в файл, и обеспечивает конечную согласованность данных между узлами.

В конечном итоге, они взаимозаменяемы в следующих задачах (с учётом дополнений в виде Telegraf): 
- простая запись метрик
- простая система оповещений
- анализ временных рядов
- визуализация данных

При условии, что не требуется конечная согласованность и задача представляет из себя преимущественно систему сбора метрик.

*Refs*:
- https://prometheus.io/docs/introduction/comparison/#prometheus-vs-influxdb
- https://docs.influxdata.com/influxdb/v2/tools/telegraf-configs/
- https://logz.io/blog/prometheus-influxdb/
- https://www.metricfire.com/blog/prometheus-vs-influxdb/

---

7. Вопрос: Пользователь обратился к tele2.ru. Как именно компьютер пользователя узнает, к какому серверу нужно отправить запрос? Опишите процесс разрешения имен.

Скажем, если пользователь обращается к tele2.ru, то прежде, чем обратиться непосредственно к серверу компании, необходимо узнать сопоставленный имени IP-адрес, перед, например, HTTP запросом будет выполнена операция разрешения имён.

Сначала компьютер пользователя просмотрим локальный кэш DNS-записей. Это может быть статическая таблица или локальный DNS-сервер. Затем, если адрес не найден, то будет отправлен запрос к внешнему DNS-серверу через локальный "gateway", процесс разрешения локально будет на каждом этапе, чтобы как можно быстрее отдать ответ. По-цепочке (рекурсивно) DNS сервера будут выполнять запросы к DNS-серверам верхних уровней, таким образом дойдя до корневых серверов и смогут ответить какие сервера отвечают за разрешение ".ru" зоны. Далее DNS сервера зоны .ru смогут обозначить какой сервер отвечает за "tele2.ru", и конечный авторитетный сервер сможет вернуть информацию о записи для "tele2.ru". После чего пользователь получит адрес, по которому уже сможет сделать, например, HTTP запрос.

Кратко:
1. Проверка локального кэша
2. Запрос к внешнему DNS-серверу (например, провайдера)
3. Рекурсивные запросы:
4. Запрос к корневым серверам (их 13 во всём мире, которые могут определить зону ответственности домена верхнего уровня)
5. Запрос корневого сервера к серверу доменной зоны верхнего уровня
6. Запрос сервера доменной зоны верхнего уровня к авторитетному серверу
7. Получение адреса
8. Отправка ответа клиенту

### Практическая часть

8. Задача: Напишите на вашем любимом языке программирования (Ruby, PHP, Python, Bash...) программу, которая будет мониторить доступность веб-сервиса (source.example.ru) каждую минуту. В случае недоступности сервиса, скрипт должен отправить уведомление на email monitoring@example.ru. Результат проверки должен записываться в лог-файл events.log c форматом записи:

```
   [2024-04-11 03:13:00] OK
   [2024-04-11 03:14:00] OK
   [2024-04-11 03:15:00] NOK
   [2024-04-11 03:16:00] OK
```

9. Задача: Напишите на вашем любимом языке программирования (Ruby, PHP, Python, Bash...) программу, которая считывает файл events.log из предыдущей задачи и выводит число событий NОК за каждый час.

Решение состоит из нескольких файлов, хотелось сделать его масштабируемым хоть сколько-нибудь, и, наверное, имеют место асинхронные вызовы, но в задаче чётко не было сказано насколько широки должны быть возможности программы.

Конфигурация основынх параметров, например, для отправки email задаётся через bootstrap.py файл, где параметры указыаются в клиенте SMTP. Аналогично для записи в файл и запроса самого ресурса. Некоторые параметры можно задавать через переменные окружения:

- SMTP_HOST, SMTP_PORT, SMTP_TIMEOUT (на подключение)
- LOG_FILE (путь к файлу для записи), LOG_VERBOSE (дублировать ли в стандартный поток вывода информацию)
- WATCHER_URL (адрес веб-ресурса)

Частоту опросов веб-сервиса можно регулировать с помощью файла cli.py, например, установив параметр 10 секунд вместо 60 (т.е. раз в минуту).

#### Для обех задач есть зависимости:
- python 3.12 или выше
- процессор с двумя и более ядрами

Чтобы установить необходимые для запуска пакеты:

1. создать вирутальное окружение командой
```bash
python3 -m venv .env
```
1. запустить окружение командой
```bash
source .env/bin/activate
```
1. установить зависимости
```bash
pip install -r requirements.txt
```
1. выполнить запуск цикла проверки доступности:
```bash
python3 cli.py run
```
или запустить считателя неудач за каждый час:
```bash
python3 cli.py log:read
```

Второй вариант установки через `poetry`, при наличии:
```bash
poetry install
```
Далее запуск как указано выше.